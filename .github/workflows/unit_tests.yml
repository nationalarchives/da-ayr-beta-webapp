name: Run Unit Tests

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  app_tests:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.11

    - name: Install Poetry
      run: pip install poetry

    - name: Install dependencies
      run: poetry install

    - name: Install Node dependencies
      run: npm install

    - name: Run build script
      run: ./build.sh

    - name: Build CSS
      run: npm run build

    - name: Run App unit tests
      run: AWS_DEFAULT_REGION=eu-west-2 poetry run pytest --cov=app/main --cov-report term-missing -rsa -vvv app/tests

    - name: Generate coverage XML
      run: poetry run coverage xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3

  data_management_tests:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up Docker Compose
      run: |
        sudo apt-get update
        sudo apt-get install -y docker-compose

    - name: Run Docker Compose Tests
      run: docker compose -f docker-compose.test.yml up --exit-code-from opensearch_indexer_tests

    - name: Copy coverage file from shared volume
      run: |
        cp ./test_results/coverage.xml ./coverage.xml || echo "Coverage file not found"

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

  run-e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.11

      - name: Install Poetry
        run: pip install poetry

      - name: Install app dependencies
        run: poetry install

      - name: Install Node dependencies
        run: npm install

      - name: Build assets
        run: |
          ./build.sh
          npm run build

      - name: Start local services
        run: | # pragma: allowlist secret
          cd local_services
          cat <<EOF > .env
          OPENSEARCH_INITIAL_ADMIN_PASSWORD=FOOBARCARabc123!
          POSTGRES_DB=local_db
          POSTGRES_USER=local_db_user
          POSTGRES_PASSWORD=local_db_user_password
          KEYCLOAK_ADMIN=admin
          KEYCLOAK_ADMIN_PASSWORD=password
          KC_POSTGRES_PORT=5432
          WEBAPP_POSTGRES_PORT=5434
          MINIO_ROOT_USER=ROOTNAME
          MINIO_ROOT_PASSWORD=CHANGEME123
          EOF

          # Create certificate directories
          mkdir -p webapp_postgres_certs opensearch_certs

          # Generate SSL certs directly
          echo "=== Generating SSL Certificates ==="
          cd webapp_postgres_certs

          # Create a private key
          openssl genrsa -out root-ca.key 2048

          # Generate a root CA
          openssl req -x509 -new -nodes -key root-ca.key -sha256 -out root-ca.pem -subj "/CN=RootCA"

          # Generate server key
          openssl genrsa -out postgres_localhost.key 2048

          # Create a self-signed certificate
          openssl req -new -key postgres_localhost.key -out postgres_localhost.csr -subj "/CN=localhost"

          # Create a CA certificate
          openssl x509 -req -in postgres_localhost.csr -CA root-ca.pem -CAkey root-ca.key -CAcreateserial -out postgres_localhost.crt -days 365 -sha256

          # Set proper permissions for GitHub Actions
          chmod 600 postgres_localhost.key root-ca.key
          chmod 644 postgres_localhost.crt root-ca.pem

          cd ..

          # Verify certificates
          echo "=== Verifying SSL Certificates ==="
          ls -la ./webapp_postgres_certs/
          echo "=== Certificate Contents ==="
          if [ -f ./webapp_postgres_certs/postgres_localhost.crt ]; then
            cat ./webapp_postgres_certs/postgres_localhost.crt
          else
            echo "Certificate file not found!"
            echo "=== Directory Contents ==="
            find ./webapp_postgres_certs -type f
            exit 1
          fi
          echo "=== Key Contents ==="
          if [ -f ./webapp_postgres_certs/postgres_localhost.key ]; then
            cat ./webapp_postgres_certs/postgres_localhost.key
          else
            echo "Key file not found!"
            echo "=== Directory Contents ==="
            find ./webapp_postgres_certs -type f
            exit 1
          fi
          echo "=== CA Contents ==="
          if [ -f ./webapp_postgres_certs/root-ca.pem ]; then
            cat ./webapp_postgres_certs/root-ca.pem
          else
            echo "CA file not found!"
            echo "=== Directory Contents ==="
            find ./webapp_postgres_certs -type f
            exit 1
          fi

          # Create a temporary docker-compose override for GitHub Actions
          cat <<EOF > docker-compose.override.yml
          services:
            webapp_postgres:
              user: postgres
              command: [
                "bash",
                "-c",
                "chmod 600 /var/lib/postgresql/postgres_localhost.key && chmod 644 /var/lib/postgresql/postgres_localhost.crt /var/lib/postgresql/root-ca.pem && postgres -c ssl=on -c ssl_cert_file=/var/lib/postgresql/postgres_localhost.crt -c ssl_key_file=/var/lib/postgresql/postgres_localhost.key -c ssl_ca_file=/var/lib/postgresql/root-ca.pem"
              ]
          EOF

          # Start services with the override
          docker compose -f docker-compose.yml -f docker-compose.override.yml up -d
          echo "Services started"

          # Debug: Check container status
          echo "=== Container Status ==="
          docker compose ps

          # Debug: Check PostgreSQL logs
          echo "=== PostgreSQL Logs ==="
          docker compose logs webapp_postgres

          # Wait for PostgreSQL to be ready
          echo "=== Waiting for PostgreSQL to be ready ==="
          timeout 60s bash -c 'until docker compose exec -T webapp_postgres pg_isready -U local_db_user; do sleep 2; echo "Waiting for PostgreSQL..."; docker compose logs --tail=50 webapp_postgres; done'

      - name: Install dependencies for textract
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            python3-dev libxml2-dev libxslt1-dev antiword unrtf poppler-utils \
            ghostscript tesseract-ocr flac ffmpeg lame libmad0 libsox-fmt-mp3 \
            sox libjpeg-dev swig zlib1g-dev

          poetry run python -m pip install --upgrade "pip<24.1"
          poetry run pip install textract

      - name: Generate SSL certs inside Docker
        run: |
          docker build -t certs-builder ./local_services/certs-builder
          docker run --rm \
            -v "$(pwd)/local_services/webapp_postgres_certs:/certs/webapp_postgres_certs" \
            -v "$(pwd)/local_services/opensearch_certs:/certs/opensearch_certs" \
            certs-builder

      - name: Run database migrations and setup test data
        run: | # pragma: allowlist secret
          export DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:${WEBAPP_POSTGRES_PORT}/${POSTGRES_DB}?sslmode=prefer
          export OPENSEARCH_URL=http://localhost:9200
          export MINIO_ENDPOINT=localhost:9000
          export MINIO_ACCESS_KEY=minioadmin
          export MINIO_SECRET_KEY=minioadmin
          export AWS_DEFAULT_REGION=eu-west-2
          export AWS_REGION=eu-west-2
          export FLASKS3_CDN_DOMAIN=""
          export FLASKS3_ACTIVE=True
          export RECORD_BUCKET_NAME="test-record-download"
          export DEFAULT_DATE_FORMAT=DD/MM/YYYY
          export DEFAULT_PAGE_SIZE=10
          export DB_PORT=5432
          export DB_HOST=localhost
          export DB_NAME=local_db
          export DB_USER=local_db_user
          export DB_PASSWORD=local_db_user_password
          export AWS_ENDPOINT_URL=http://localhost:9000
          export FLASKS3_BUCKET_NAME="test-record-download"
          export DB_SSL_ROOT_CERTIFICATE=local_services/webapp_postgres_certs/root-ca.pem
          export OPEN_SEARCH_CA_CERTS=local_services/opensearch_certs/root-ca.pem
          export KEYCLOAK_BASE_URI=http://localhost:8080
          export KEYCLOAK_REALM_NAME=tdr
          export KEYCLOAK_CLIENT_ID=ayr-beta
          export KEYCLOAK_CLIENT_SECRET=bTOIXx2JXA9XzevkpWn3lQG27diVCTHa
          export OPEN_SEARCH_HOST=https://localhost:9200
          export OPEN_SEARCH_USERNAME=admin
          export OPEN_SEARCH_PASSWORD=FOOBARCARabc123!
          export OPEN_SEARCH_CA_CERTS=local_services/opensearch_certs/root-ca.pem
          export OPEN_SEARCH_TIMEOUT=10
          export PERF_TEST=false
          export SECRET_KEY="secret"

          # Import test files and index them
          poetry run python local_services/mds_data_generator/mds_test_file_importer.py || echo "Failed to import test files"

      - name: Start Flask application
        run: | # pragma: allowlist secret
          export DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:${WEBAPP_POSTGRES_PORT}/${POSTGRES_DB}?sslmode=prefer
          export OPENSEARCH_URL=http://localhost:9200
          export MINIO_ENDPOINT=localhost:9000
          export MINIO_ACCESS_KEY=minioadmin
          export MINIO_SECRET_KEY=minioadmin
          export FLASK_ENV=testing
          export AWS_DEFAULT_REGION=eu-west-2
          export AWS_REGION=eu-west-2
          export FLASKS3_CDN_DOMAIN=""
          export FLASKS3_ACTIVE=True
          export RECORD_BUCKET_NAME="test-record-download"
          export DEFAULT_DATE_FORMAT=DD/MM/YYYY
          export DEFAULT_PAGE_SIZE=10
          export DB_PORT=5432
          export DB_HOST=localhost
          export DB_NAME=local_db
          export DB_USER=local_db_user
          export DB_PASSWORD=local_db_user_password
          export AWS_ENDPOINT_URL=http://localhost:9000
          export DB_SSL_ROOT_CERTIFICATE=local_services/webapp_postgres_certs/root-ca.pem
          export OPEN_SEARCH_CA_CERTS=local_services/opensearch_certs/root-ca.pem
          export FLASKS3_BUCKET_NAME="test-record-download"
          export KEYCLOAK_BASE_URI=http://localhost:8080
          export KEYCLOAK_REALM_NAME=tdr
          export KEYCLOAK_CLIENT_ID=ayr-beta
          export KEYCLOAK_CLIENT_SECRET=bTOIXx2JXA9XzevkpWn3lQG27diVCTHa
          export OPEN_SEARCH_HOST=https://localhost:9200
          export OPEN_SEARCH_USERNAME=admin
          export OPEN_SEARCH_PASSWORD=FOOBARCARabc123!
          export OPEN_SEARCH_TIMEOUT=10
          export PERF_TEST=false
          export SECRET_KEY="secret"

          # Start Flask with more verbose output
          nohup poetry run python -u main_app.py > flask.log 2>&1 &
          echo $! > flask.pid

          # Show logs immediately
          echo "=== Flask Application Logs ==="
          sleep 5
          cat flask.log

          echo "Waiting for Flask application to start"
          timeout 60s bash -c 'until curl -s http://127.0.0.1:5000; do sleep 2; echo "Still waiting..."; cat flask.log; done'
          echo "Flask application is ready"

      - name: Install E2E test dependencies
        run: |
          cd e2e_tests/
          poetry install --no-root
          poetry run playwright install --with-deps

      - name: Run E2E tests
        env:
          KEYCLOAK_BASE_URI: http://localhost:8080
          KEYCLOAK_CLIENT_ID: test-client
          KEYCLOAK_REALM_NAME: test
          KEYCLOAK_CLIENT_SECRET: test-secret # pragma: allowlist secret
          WEBAPP_BASE_URL: http://localhost:5000
        run: |
          cd e2e_tests/
          poetry run pytest . \
            --base-url=http://localhost:5000 \
            -k "not test_css_no_visual_regression" \
            -vvv \
            -rsa \
            --slowmo 100 \
            --tracing on \
            --browser chromium \
            --html=e2e-report.html \
            --self-contained-html

      - name: Upload E2E test results
        # if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results
          path: |
            e2e_tests/e2e-report.html
            e2e_tests/test-results/
            flask.log

      - name: Cleanup services
        # if: always()
        run: |
          if [ -f flask.pid ]; then
            kill $(cat flask.pid) || true
          fi
          cd local_services
          docker compose down -v || true

      - name: Show Flask logs on failure
        # if: failure()
        run: |
          echo "=== Flask Application Logs ==="
          cat flask.log || echo "No Flask logs found"
